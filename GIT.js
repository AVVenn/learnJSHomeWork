// ____________________________________________________________________________________________________________________________________
// редоктор кода будет vs code а не vim
// setx path "%path%;F:\Games\Microsoft VS Code\Code.exe
// git config --global core.editor code

//todo git config --global core.editor "code --wait"
//todo git config --global -e
//todo https://code.visualstudio.com/docs/editor/versioncontrol#_vs-code-as-git-editor
// ____________________________________________________________________________________________________________________________________
//? 1. Нужно поставить Git Bash
// ____________________________________________________________________________________________________________________________________
//? 2. Создаем репозиторием в Github и копируем ссылку  на репозиторий
// ____________________________________________________________________________________________________________________________________
//? 3. Создаем терминал и в нем инициализируем git  (git init)
// ____________________________________________________________________________________________________________________________________
//? 4.  Прописываем
//  git config --global user.name ”Ivan Ivanov”
// 	git config --global user.email ivan.ivanov@gmail.com
// 	c:\Users\VeN\  - лежит файлик gitconfig
// ____________________________________________________________________________________________________________________________________
//? 5. Полезные Alias в gitconfig
// [alias]
// 	s =  status --short
// 	st = status
// 	l = log --oneline --graph --decorate --all
// 	g = log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)'
// 	br = branch
// 	co = checkout
// ____________________________________________________________________________________________________________________________________

//? 6.1  http://iantonov.me/page/kak-nachat-ispolzovat-git-chast-1-generiruem-ssh-kljuchi   - можно через SSH подключить
// ____________________________________________________________________________________________________________________________________

//? 6.2   подключаем репозиторий к github  ( git remote  - набор команд , которое отвечает за внешние контакты )  git remote add origin , origin это название переменной.      git remote show - покажет ссылки     git remote -h   - ифа о командах         

// ____________________________________________________________________________________________________________________________________
//? 7. git add .  или  git add index.html script.js  - закинуть файлы на stage      
//  git reset index.html -  убрать из stage файл

// ____________________________________________________________________________________________________________________________________
//? 8. git commit -m ""  

// ____________________________________________________________________________________________________________________________________
//? 9. Убрать отметку M и изменения в index html      =      git checkout -- index.html 
 
// ____________________________________________________________________________________________________________________________________

//? 10 Вернуться на 1 комит обратно  git reset --hard HEAD^1 - удалится все, что было неправильно закомичено  
//  git reset --soft HEAD^1  - откатить комит сохранится все 

// ____________________________________________________________________________________________________________________________________

//? 11 за подразделение по веткам отвечает git branch 
    // git branch -m имя  - переименовать ветку текущую    
//  git branch -d имя -удалить ветку

// ____________________________________________________________________________________________________________________________________

//? 12 за подразделение передвижения по веткам  git checkout имя     git checkout -b   

// https://javarush.ru/groups/posts/2683-nachalo-rabotih-s-git-podrobnihy-gayd-dlja-novichkov

// ____________________________________________________________________________________________________________________________________

//? 13. Для того чтобы объединить 2 ветки , заходим на ту к которой будем присоединять и git merge имя ветки ,которую мерджим  - создается новый коммит , который вкллючает объедиения 2х

// git checkout feature
// git merge main
// При желании этот код можно записать в одну строку:

// git merge feature main

// для того чтобы вернуться на 1 родителя мерж git checkout имя^
// для того чтобы вернуться на 1 родителя мерж git checkout имя^2
// Эта операция создает в ветке feature новый «коммит слияния», связывающий истории обеих веток.

// ____________________________________________________________________________________________________________________________________

//? 14.  git rebase  - создается новый комит , как буд-то  все коммиты последовательноо совершались в ветке, куда происходил rebase , rebase и куда перемещаем
//? rebase делается из ветки которую хотим переместить
//* git rebase <основная ветка> <тематическая ветка>, 

//* Отменить процесс rebase набрав в консоли  git rebase --abort
// Разрешить конфликт в вашем любимом merge-tool'е, подготовить файлы к коммиту, набрав git add %filename%. Проделав это со всеми конфликтными файлами, продолжить процесс rebase-а набрав в консоли  git rebase --continue

//* Золотое правило для команды git rebase — никогда не использовать ее в публичных ветках... 
// Перемещайте изменения только на вашей приватной локальной ветке — не перемещайте коммиты, от которых зависит ещё кто-то.

// Главное преимущество rebase — более чистая история проекта. Во-первых, эта команда устраняет ненужные коммиты слияния, необходимые для git merge. Во-вторых, как показано на рисунке выше, команда rebase создает идеальную линейную историю проекта — вы сможете отследить функционал до самого начала проекта без каких-либо форков.

// Однако такая безупречная история коммитов требует определенных жертв: жертвовать приходится безопасностью и отслеживаемостью. Если не следовать Золотому правилу Rebase, перезапись истории проекта может обернуться катастрофическими последствиями для совместных рабочих процессов. Кроме того, при выполнении rebase теряется контекст, доступный в коммите со слиянием: вы не сможете увидеть, когда вышестоящие изменения были включены в функционал.

https://habr.com/ru/post/161009/?mobile=yes

// ____________________________________________________________________________________________________________________________________

//? 15  Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:  

// Перемещение на один коммит назад ^
// Перемещение на несколько коммитов назад ~<num>

// оператор каретки (^). Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.

// Так что main^ означает "первый родитель ветки main".

// ____________________________________________________________________________________________________________________________________

//? 16  Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать ^ несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (~).

// К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти. Посмотрим, как это работает.

// git checkout HEAD~4

// ____________________________________________________________________________________________________________________________________

//? 17 Перемещение ветки (branch forcing)
// Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.

// Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции -f. Например, команда:

// git branch -f main HEAD~3

// Переместит (принудительно) ветку main на три родителя назад от HEAD.

// ____________________________________________________________________________________________________________________________________

//? 18 Отмена изменений 

// git reset отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.

// git reset насколько назад (HEAD^1)

//? Чтобы отменить изменения котоорые уже на гитхаб, надо использовать git revert. Он создаст новый коммит который будет идентичен с предпоследним .  необхомо указать имя -m

// ____________________________________________________________________________________________________________________________________
//? 19 Git Cherry-pick
// Первая из таких команд - это git cherry-pick. Она выглядит вот так:

// git cherry-pick <Commit1> <Commit2> <...>
// Это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD). Мы обожаем cherry-pick за то, что в нём очень мало магии и его очень просто понять и применять.

// Git cherry-pick прекрасен, когда точно известно, какие коммиты нужны (и известны их точные хеши)

// ____________________________________________________________________________________________________________________________________

//? 20 git rebase -i HEAD~4
// После открытия окна интерактивного rebase есть три варианта для каждого коммита:

//* Можно сменить положение коммита по порядку, переставив строчку с ним в редакторе (у нас в окошке строку с коммитом можно перенести просто мышкой).
//* Можно "выкинуть" коммит из ребейза. Для этого есть drop
//* Наконец, можно соединить коммиты. fixup || squash

// Действию, которое мы собираемся произвести над коммитами, соответствует кодовое слово squash. В данном случае следует помнить лишь об одной тонкости: строка, помеченная «squash», будет объединена со строкой, которая находится выше нее. Именно поэтому на скриншоте выше я пометил словом squash строку №2 (она будет объединена со строкой №1).

// Именно для таких случаев и предназначен fixup. Этот инструмент берет коммит с быстрым исправлением, применяет его изменения к оригинальном коммиту (тем самым исправляя его), и удаляет корректирующий коммит.
// https://habr.com/ru/company/flant/blog/536698/

//* reword - перефразировать описание коммита

// Если есть конфликты слияния, вам нужно будет их разрешить, а затем использовать . В любой момент вы можете использовать для возврата в исходное состояние.  git rebase --continue   
// git rebase --abort  - отменить rebase

// ____________________________________________________________________________________________________________________________________
//? git --amend - изменить текущий коммит
// ____________________________________________________________________________________________________________________________________
//todo git tag v1 #4545354 - Создаем тег опр комита куда потом можем прыгать через checkout

//?  На всякий случай, помни, что всегда можно исправить ошибку, вызвав команду undo или reset.

// ____________________________________________________________________________________________________________________________________
//? УДАЛЕННЫЕ РЕПОЗИТОРИИ

// Технически, git clone в реальной жизни - это команда, которая создаст локальную копию удалённого репозитория (например, с GitHub). На наших занятиях в Learn Git Branching мы используем эту команду немного иначе - git clone создаёт удалённый репозиторий на основе вашего локального репозитория.



// https://learngitbranching.js.org/?locale=ru_RU

// git pull --rebase

// https://habr.com/ru/post/174467/
