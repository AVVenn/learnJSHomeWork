// let phrase = "Hello";

// if (true) {
//   let user = "John";

//   function sayHi() {
//     alert(`${phrase}, ${user}`);   // почему буде ошибка? да, у if есть свой  скоп в котором есть переменная юзер   и сэй хай пойдет искать эту переменную потому что своей нет и найдет 
//   }
// }

// sayHi();

// Лексическое окружение === скоуп
// В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.
// Объект лексического окружения состоит из двух частей:
// Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
// Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

// let phrase;     // phrase:undefined // outer --- null
// phrase = `hello`;  // phrase: `hello`   
// phrase = `Bye` // phrase: `bye`  // "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».


// Function Declaration   
// В отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение == скоуп;
// Для верхнеуровневых функций это означает момент, когда скрипт начинает выполнение.
// Вот почему мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена.


// let phrase = `hello`;     //1) say: function    //2) say: function phrase: "Hello"
// function say (name){    
//     alert (`${phrase}, ${name}`;)  
// }

// При запуске функции для неё автоматически создаётся новое лексическое окружение, для хранения локальных переменных и параметров вызова.

// let phrase = `hello`;     //1) say: function    //2) say: function phrase: "Hello"
// function say (name){    
//     alert (`${phrase}, ${name}`;)  
// }
// say (`Jouh`);  // 1) name: `John`  2) say: function phrase: "Hello" 

// Итак, в процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное):
// Внутреннее лексическое окружение соответствует текущему выполнению say.
// В нём находится одна переменная name, аргумент функции. Мы вызываем say("John"), так что значение переменной name равно "John".
// Внешнее лексическое окружение – это глобальное лексическое окружение. В нём находятся переменная phrase и сама функция.


// Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.