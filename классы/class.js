// Синтаксис «class»
// Базовый синтаксис выглядит так:

// class MyClass {
//   // методы класса
//   constructor() { ... }
//   method1() { ... }
//   method2() { ... }
//   method3() { ... }
//   ...
// }

// Затем используйте вызов new MyClass() для создания нового объекта со всеми перечисленными методами.
// При этом автоматически вызывается метод constructor(), в нём мы можем инициализировать объект.
// ___________________________________________________________________________________________
// class User {
//     constructor(name) {
//     this.name = name;
//     }
//     sayHi() {
//     alert(this.name);
//     }
// }
//   // Использование:
// let user = new User("Иван");
// user.sayHi();
// ___________________________________________________________________________________________

// Когда вызывается new User("Иван"):
// Создаётся новый объект.
// constructor запускается с заданным аргументом и сохраняет его в this.name.
// …Затем можно вызывать на объекте методы, такие как user.sayHi().
// ___________________________________________________________________________________________
// Методы в классе не разделяются запятой
// ___________________________________________________________________________________________
// В JavaScript класс – это разновидность функции.

// class User {
//     constructor(name) { this.name = name; }
//     sayHi() { alert(this.name); }
//   }
//    доказательство: User - это функция
//   alert(typeof User); // function

// ___________________________________________________________________________________________
// Вот что на самом деле делает конструкция class User {...}:
// Создаёт функцию с именем User, которая становится результатом объявления класса. Код функции берётся из метода constructor (она будет пустой, если такого метода нет).
// Сохраняет все методы, такие как sayHi, в User.prototype.
// При вызове метода объекта new User он будет взят из прототипа, как описано в главе F.prototype. Таким образом, объекты new User имеют доступ к методам класса.
// ___________________________________________________________________________________________

// Иногда говорят, что class – это просто «синтаксический сахар» в JavaScript (синтаксис для улучшения читаемости кода, но не делающий ничего принципиально нового), потому что мы можем сделать всё то же самое без конструкции class - через new

// Однако есть важные отличия:
// Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством [[IsClassConstructor]]: true. Поэтому это не совсем то же самое, что создавать её вручную.
// В отличие от обычных функций, конструктор класса не может быть вызван без new:

// Методы класса являются неперечислимыми. Определение класса устанавливает флаг enumerable вfalse для всех методов в "prototype".
// И это хорошо, так как если мы проходимся циклом for..in по объекту, то обычно мы не хотим при этом получать методы класса.

// Классы всегда используют use strict. Весь код внутри класса автоматически находится в строгом режиме. 

// ___________________________________________________________________________________________
// Наследование классов

// Допустим, у нас есть два класса.

// class Animal {
//     constructor(name) {
//         this.speed = 0;
//         this.name = name;
//     }
//     run(speed) {
//         this.speed = speed;
//         alert(`${this.name} бежит со скоростью ${this.speed}.`);
//     }
//     stop() {
//         this.speed = 0;
//         alert(`${this.name} стоит.`);
//     }
//   }
// let animal = new Animal("Мой питомец");


// class Rabbit {
//     constructor(name) {
//         this.name = name;
//     }
//     hide() {
//         alert(`${this.name} прячется!`);
//     }
//   }
// let rabbit = new Rabbit("Мой кролик");

// Сейчас они полностью независимы.
// Но мы хотим, чтобы Rabbit расширял Animal. Другими словами, кролики должны происходить от животных, т.е. иметь доступ к методам Animal и расширять функциональность Animal своими методами.

// Для того, чтобы наследовать класс от другого, мы должны использовать ключевое слово "extends" и указать название родительского класса перед {..}.

// class Animal {
//     constructor(name) {
//       this.speed = 0;
//       this.name = name;
//     }
//     run(speed) {
//       this.speed = speed;
//       alert(`${this.name} бежит со скоростью ${this.speed}.`);
//     }
//     stop() {
//       this.speed = 0;
//       alert(`${this.name} стоит.`);
//     }
//   }
//   Наследуем от Animal указывая "extends Animal"
//   class Rabbit extends Animal {
//     hide() {
//       alert(`${this.name} прячется!`);
//     }
//   }
//   let rabbit = new Rabbit("Белый кролик");
//   rabbit.run(5); // Белый кролик бежит со скоростью 5.
//   rabbit.hide(); // Белый кролик прячется!


// Теперь код Rabbit стал короче, так как используется конструктор класса Animal по умолчанию и кролик может использовать метод run как и все животные.
// Ключевое слово extends работает, используя прототипы. Оно устанавливает Rabbit.prototype.[[Prototype]] в Animal.prototype. Так что если метод не найден в Rabbit.prototype, JavaScript берёт его из Animal.prototype.

// ___________________________________________________________________________________________
// После extends разрешены любые выражения
// Синтаксис создания класса допускает указывать после extends не только класс, но любое выражение.
// Пример вызова функции, которая генерирует родительский класс:

// function f(phrase) {
//     return class {
//       sayHi() { alert(phrase) }
//     }
//   }
//   class User extends f("Привет") {}
//   new User().sayHi(); // Привет

// Здесь class User наследует от результата вызова f("Привет").
// Это может быть полезно для продвинутых приёмов проектирования, где мы можем использовать функции для генерации классов в зависимости от многих условий и затем наследовать их.

// ___________________________________________________________________________________________
// Переопределение методов

// Давайте пойдём дальше и переопределим метод. Сейчас Rabbit наследует от Animal метод stop, который устанавливает this.speed = 0.
// Если мы определим свой метод stop в классе Rabbit, то он будет использоваться взамен родительского:

// class Rabbit extends Animal {
//   stop() {
//     // ...будет использован для rabbit.stop()
//   }
// }

// …Впрочем, обычно мы не хотим полностью заменить родительский метод, а скорее хотим сделать новый на его основе, изменяя или расширяя его функциональность. Мы делаем что-то в нашем методе и вызываем родительский метод до/после или в процессе.

// У классов есть ключевое слово "super" для таких случаев.
// super.method(...) вызывает родительский метод.
// super(...) вызывает родительский конструктор (работает только внутри нашего конструктора).
// Пусть наш кролик автоматически прячется при остановке:


// class Animal {
//     constructor(name) {
//         this.speed = 0;
//         this.name = name;
//     }
//     run(speed) {
//         this.speed = speed;
//         alert(`${this.name} бежит со скоростью ${this.speed}.`);
//     }
//     stop() {
//         this.speed = 0;
//         alert(`${this.name} стоит.`);
//     }
// }

// class Rabbit extends Animal {
//     hide() {
//         alert(`${this.name} прячется!`);
//     }
//     stop() {
//       super.stop(); // вызываем родительский метод stop
//       this.hide(); // и затем hide
//     }
// }
// let rabbit = new Rabbit("Белый кролик");
//   rabbit.run(5); // Белый кролик бежит со скоростью 5.
//   rabbit.stop(); // Белый кролик стоит. Белый кролик прячется!

// ___________________________________________________________________________________________
// У стрелочных функций нет super
// При обращении к super стрелочной функции он берётся из внешней функции:

// class Rabbit extends Animal {
//     stop() {
//     setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
//     }
// }
// В примере super в стрелочной функции тот же самый, что и в stop(), поэтому метод отрабатывает как и ожидается. Если бы мы указали здесь «обычную» функцию, была бы ошибка:

// // Unexpected super
// setTimeout(function() { super.stop() }, 1000);

// ___________________________________________________________________________________________
// Переопределение конструктора

// С конструкторами немного сложнее.
// До сих пор у Rabbit не было своего конструктора.
// Согласно спецификации, если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор:

// class Rabbit extends Animal {
//   // генерируется для классов-потомков, у которых нет своего конструктора
//   constructor(...args) {
//     super(...args);
//   }
// }
// Как мы видим, он просто вызывает конструктор родительского класса. Так будет происходить, пока мы не создадим собственный конструктор.

// ____________
// в классах-потомках конструктор обязан вызывать super(...), и (!) делать это перед использованием this.

// В JavaScript существует различие между «функцией-конструктором наследующего класса» и всеми остальными. В наследующем классе соответствующая функция-конструктор помечена специальным внутренним свойством [[ConstructorKind]]:"derived".

// Разница в следующем:
// Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его this .
// Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.
// Поэтому, если мы создаём собственный конструктор, мы должны вызвать super, в противном случае объект для this не будет создан, и мы получим ошибку.

// Чтобы конструктор Rabbit работал, он должен вызвать super() до того, как использовать this, чтобы не было ошибки:
// class Animal {
//     constructor(name) {
//     this.speed = 0;
//     this.name = name;
//     }
//   // ...
// }

// class Rabbit extends Animal {
//     constructor(name, earLength) {
//     super(name); /!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//     this.earLength = earLength;
//     }
//   // ...
// }

// // теперь работает
// let rabbit = new Rabbit("Белый кролик", 10);
// alert(rabbit.name); // Белый кролик
// alert(rabbit.earLength); // 10
// ___________________________________________________________________________________________

// Статические свойства и методы

// Мы также можем присвоить метод самой функции-классу, а не её "prototype". Такие методы называются статическими.
// В классе такие методы обозначаются ключевым словом static, например:

// class User {
//   static staticMethod() {
//     alert(this === User);
//   }
// }

// User.staticMethod(); // true


// Например, есть объекты статей Article, и нужна функция для их сравнения. Естественное решение – сделать для этого метод Article.compare:
// class Article {
// constructor(title, date) {
//     this.title = title;
//     this.date = date;
//     }
//     static compare(articleA, articleB) {
//     return articleA.date - articleB.date;
//     }
// }

// // использование
// let articles = [
//     new Article("HTML", new Date(2019, 1, 1)),
//     new Article("CSS", new Date(2019, 0, 1)),
//     new Article("JavaScript", new Date(2019, 11, 1))
// ];

// articles.sort(Article.compare);

// alert( articles[0].title ); // CSS
// ___________________________________________________________________________________________
// Статические свойства

// Статические свойства также возможны, они выглядят как свойства класса, но с static в начале:

// class Article {
//   static publisher = "Илья Кантор";
// }
// alert( Article.publisher ); // Илья Кантор
// Это то же самое, что и прямое присваивание Article:

// Article.publisher = "Илья Кантор";

// ___________________________________________________________________________________________
// Статические свойства и методы наследуются.
// ___________________________________________________________________________________________

// Проверка класса: "instanceof"
// Оператор instanceof позволяет проверить, к какому классу принадлежит объект, с учётом наследования.
// Такая проверка может потребоваться во многих случаях. 

// Синтаксис:
// obj instanceof Class   // Оператор вернёт true, если obj принадлежит классу Class или наследующему от него.

// Например:
// class Rabbit {}
// let rabbit = new Rabbit();

// // это объект класса Rabbit?
// alert( rabbit instanceof Rabbit ); // true


// Также это работает с функциями-конструкторами:

// function Rabbit() {} // вместо класса

// alert( new Rabbit() instanceof Rabbit ); // true
// …И для встроенных классов, таких как Array:

// let arr = [1, 2, 3];
// alert( arr instanceof Array ); // true
// alert( arr instanceof Object ); // true
// Пожалуйста, обратите внимание, что arr также принадлежит классу Object, потому что Array наследует от Object.

// ___________________________________________________________________________________________
// Бонус: Object.prototype.toString возвращает тип
// Мы уже знаем, что обычные объекты преобразуется к строке как [object Object]:

// let obj = {};

// alert(obj); // [object Object]
// alert(obj.toString()); // то же самое


// Так работает реализация метода toString. Но у toString имеются скрытые возможности, которые делают метод гораздо более мощным. Мы можем использовать его как расширенную версию typeof и как альтернативу instanceof.

// Согласно спецификации встроенный метод toString может быть позаимствован у объекта и вызван в контексте любого другого значения. И результат зависит от типа этого значения.

// Для числа это будет [object Number]
// Для булева типа это будет [object Boolean]
// Для null: [object Null]
// Для undefined: [object Undefined]
// Для массивов: [object Array]
// …и т.д. (поведение настраивается).
// Давайте продемонстрируем:

// // скопируем метод toString в переменную для удобства
// let objectToString = Object.prototype.toString;

// // какой это тип?
// let arr = [];

// alert( objectToString.call(arr) ); // [object Array]

// / ___________________________________________________________________________________________
// ПРИМЕР С ПАРЫ

//  class Animal {
//     constructor (name,age) {
//         this.name = name;
//         this.age = age;
//     }

//     eat () {
//         return `${this.name} eats`;
//     }
// }

// class Human extends Animal {
//     constructor (job, ...args) { // [name, age]
//         super(...args);
//         this.job = job;
//     }

//     learn (technology){
//         console.log(super.eat());
//         return `${this.name} learns ${technology}`;
//     }

//     eat () {
//         const eatAsAnimal = super.eat();
//         return eatAsAnimal + ' with a fork';
//     }
// }

// const h1 = new Human('bus-driver', 'David', 23);

// console.log(h1.eat());


