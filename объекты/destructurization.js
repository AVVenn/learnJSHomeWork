// Деструктурирующее присваивание

// Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных, так как иногда они более удобны. Деструктуризация также прекрасно работает со сложными функциями, которые имеют много параметров, значений по умолчанию и так далее.


// Деструктуризация массива

// у нас есть массив с именем и фамилией
// let arr = ["Ilya", "Kantor"]
// деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]
// let [firstName, surname] = arr;
// alert(firstName); // Ilya
// alert(surname);  // Kantor

// Отлично смотрится в сочетании со split или другими методами, возвращающими массив:
// let [firstName, surname] = "Ilya Kantor".split(' ');

// __________________________________________________________________________________________________________________________________
// ................................................................«Деструктуризация» не означает «разрушение».
// «Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные.
// Это просто короткий вариант записи:

// let [firstName, surname] = arr;
// let firstName = arr[0];
// let surname = arr[1];

// __________________________________________________________________________________________________________________________________
// ...............................................................Пропускайте элементы, используя запятые
// Ненужные элементы массива также могут быть отброшены через запятую:

//  второй элемент не нужен
// let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// alert( title ); // Consul
// В примере выше второй элемент массива пропускается, а третий присваивается переменной title, оставшиеся элементы массива также пропускаются (так как для них нет переменных).


// __________________________________________________________________________________________________________________________________
// ................................................................Работает с любым перебираемым объектом с правой стороны
// …На самом деле мы можем использовать любой перебираемый объект, не только массивы:

// let [a, b, c] = "abc";
// let [one, two, three] = new Set([1, 2, 3]);

// __________________________________________________________________________________________________________________________________
// ..................................................................Присваивайте чему угодно с левой стороны
// Мы можем использовать что угодно «присваивающее» с левой стороны.

// Например, можно присвоить свойству объекта:

// let user = {};
// [user.name, user.surname] = "Ilya Kantor".split(' ');
// console.log (user.name); // Ilya

// __________________________________________________________________________________________________________________________________
// ..................................................................Остаточные параметры «…»

// Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):

// let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// alert(name1); // Julius
// alert(name2); // Caesar

//  Обратите внимание, что `rest` является массивом.
// alert(rest[0]); // Consul
// alert(rest[1]); // of the Roman Republic
// alert(rest.length); // 2
// Переменная rest является массивом из оставшихся элементов. Вместо rest можно использовать любое другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на последнем месте в деструктурирующем присваивании.

// __________________________________________________________________________________________________________________________________
// ................................................................................................Значения по умолчанию

// Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:

// let [firstName, surname] = [];
// alert(firstName); // undefined
// alert(surname); // undefined

// Если нам необходимо указать значения по умолчанию, то мы можем использовать =:
//  значения по умолчанию
// let [name = "Guest", surname = "Anonymous"] = ["Julius"];
// alert(name);    // Julius (из массива)
// alert(surname); // Anonymous (значение по умолчанию)
// Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

// Например, здесь мы используем функцию prompt для указания двух значений по умолчанию. Но она будет запущена только для отсутствующего значения:
//  prompt запустится только для surname
// let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];
// alert(name);    // Julius (из массива)
// alert(surname); // результат prompt

// __________________________________________________________________________________________________________________________________
// ..................................................................ДЕСТРУКТУРИЗАЦИЯ ОБЪЕКТА
// Деструктурирующее присваивание также работает с объектами.
// Синтаксис:

// let {var1, var2} = {var1:…, var2:…}
// У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон» для соответствующих свойств. В простом случае это список названий переменных в {...}.

// Например:
// let options = {
//   title: "Menu",
//   width: 100,
//   height: 200
// };

// let {title, width, height} = options;

// alert(title);  // Menu
// alert(width);  // 100
// alert(height); // 200
// Свойства options.title, options.width и options.height присваиваются соответствующим переменным. Порядок не имеет значения. Вот так – тоже работает:

//  изменён порядок в let {...}
// let {height, width, title} = { title: "Menu", height: 200, width: 100 }


// Шаблон с левой стороны может быть более сложным и определять соответствие между свойствами и переменными.
// Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w, то мы можем использовать двоеточие:

// let options = {
//   title: "Menu",
//   width: 100,
//   height: 200
// };

// { sourceProperty: targetVariable }
// let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

// alert(title);  // Menu
// alert(w);      // 100
// alert(h);      // 200

// ...............Двоеточие показывает «что : куда идёт». В примере выше свойство width сохраняется в переменную w, свойство height сохраняется в h, а title присваивается одноимённой переменной.

// Для потенциально отсутствующих свойств мы можем установить значения по умолчанию, используя "=", как здесь:

// let options = {
//   title: "Menu"
// };

// let {width = 100, height = 200, title} = options;

// alert(title);  // Menu
// alert(width);  // 100
// alert(height); // 200
// Как и в случае с массивами, значениями по умолчанию могут быть любые выражения или даже функции. Они выполнятся, если значения отсутствуют.

// В коде ниже prompt запросит width, но не title:
// let options = {
//   title: "Menu"
// };
// let {width = prompt("width?"), title = prompt("title?")} = options;
// alert(title);  // Menu
// alert(width);  // (результат prompt)
// Мы также можем совмещать : и =:

// let options = {
//   title: "Menu"
// };
// let {width: w = 100, height: h = 200, title} = options;
// alert(title);  // Menu
// alert(w);      // 100
// alert(h);      // 200

// __________________________________________________________________________________________________________________________________
// ............................................................Остаток объекта «…»

// Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?
// Можно использовать троеточие, как и для массивов. В некоторых старых браузерах (IE) это не поддерживается, используйте Babel для полифила.
// Выглядит так:

// let options = {
//   title: "Menu",
//   height: 200,
//   width: 100
// };

// title = свойство с именем title
// rest = объект с остальными свойствами
// let {title, ...rest} = options;

// сейчас title="Menu", rest={height: 200, width: 100}
// alert(rest.height);  // 200
// alert(rest.width);   // 100
// __________________________________________________________________________________________________________________________________

// Чтобы показать JavaScript, что это не блок кода, мы можем заключить выражение в скобки (...):


// let title, width, height;
//  ошибка будет в этой строке
// {title, width, height} = {title: "Menu", width: 200, height: 100}; // напишет что = там что-то;


// let title, width, height;
//   всё работает
// ({title, width, height} = {title: "Menu", width: 200, height: 100});
// alert( title ); // Menu

// __________________________________________________________________________________________________________________________________
// ........................................Вложенная деструктуризация

// Если объект или массив содержит другие вложенные объекты или массивы, то мы можем использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.
// В приведённом ниже коде options хранит другой объект в свойстве size и массив в свойстве items. Шаблон в левой части присваивания имеет такую же структуру, чтобы извлечь данные из них:
// let options = {
//     size: {
//       width: 100,
//       height: 200
//     },
//     items: ["Cake", "Donut"],
//     extra: true
// };

//   деструктуризация разбита на несколько строк для ясности
// let {
//     size: { // положим size сюда
//       width,
//       height
//     },
//     items: [item1, item2], // добавим элементы к items
//     title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
// } = options;
  
//   alert(title);  // Menu
//   alert(width);  // 100
//   alert(height); // 200
//   alert(item1);  // Cake
//   alert(item2);  // Donut


// __________________________________________________________________________________________________________________________________
// ..........................................................Умные параметры функций
// Есть ситуации, когда функция имеет много параметров, большинство из которых не обязательны. Это особенно верно для пользовательских интерфейсов. Представьте себе функцию, которая создаёт меню. Она может иметь ширину, высоту, заголовок, список элементов и так далее.

// На помощь приходит деструктуризация!
// Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные:
// мы передаём объект в функцию
// let options = {
//     title: "My menu",
//     items: ["Item1", "Item2"]
//   };
//    ...и она немедленно извлекает свойства в переменные
//   function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
//     title, items – взято из options,
//     width, height – используются значения по умолчанию
//     alert( `${title} ${width} ${height}` ); // My Menu 200 100
//     alert( items ); // Item1, Item2
//   }
//   showMenu(options);


// Пожалуйста, обратите внимание, что такое деструктурирование подразумевает, что в showMenu() будет обязательно передан аргумент. Если нам нужны все значения по умолчанию, то нам следует передать пустой объект:
// showMenu({}); // ок, все значения - по умолчанию

// showMenu(); // так была бы ошибка
// Мы можем исправить это, сделав {} значением по умолчанию для всего объекта параметров:

// function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
//   alert( `${title} ${width} ${height}` );
// }

// showMenu(); // Menu 100 200
// В приведённом выше коде весь объект аргументов по умолчанию равен {}, поэтому всегда есть что-то, что можно деструктурировать.

// __________________________________________________________________________________________________________________________________
//  МОИ ПРИМЕРЫ
// let arr = [`Andrey`, `Vasilevich`, `Avven`];
// let [name, , login] = arr; 
// alert (name); // Andrey
// alert (login); //Avven


// let [one, two, three] = `СЕГОДНЯ`;
// alert (one); // C
// alert (two); // Е
// alert (three); // Г


// let arr = [`Andrey`, `Vasilevich`, `Avven`];
// let [name = , ...ostalnoe] = arr;
// console.log(name);
// console.log(ostalnoe);


// let arr = [`Andrey`, `Vasilevich`, `Avven`];
// let [name = `Vasiliy`, , , hz = prompt(`Введите что-нибудь`), th = `rdfbdfbdf`] = arr;
// console.log(name);
// console.log (hz);   // что в промте введешь , то и получишь
// console.log(th); // rdfbdfbdf

// let options = {
//   title: "Menu",
//   width: 100,
//   height: 200
// };
// let {title: t, width, height, val: v = prompt(`Ввведите что-нибудь`)} = options;
// alert (t);
// alert (width);
// alert (v);


// let options = {
//   title: "Menu",
//   width: 100,
//   height: 200
// };
// let {title: t, ...ostalbnoe} = options;
// console.log (t);
// console.log  (ostalbnoe);


// важность: 5
// У нас есть объект salaries с зарплатами:

// let salaries = {
//   "John": 100,
//   "Pete": 300,
//   "Mary": 250
// };

// Создайте функцию topSalary(salaries), которая возвращает имя самого высокооплачиваемого сотрудника.

// Если объект salaries пустой, то нужно вернуть null.
// Если несколько высокооплачиваемых сотрудников, можно вернуть любого из них.
// P.S. Используйте Object.entries и деструктурирование, чтобы перебрать пары ключ/значение.


// function topSalary(salaries) {
//     let max = 0;
//     let maxName = null;
//     for(const [name, salary] of Object.entries(salaries)) {
//         if (max < salary) {
//         max = salary;
//         maxName = name;
//         }
//     }
//     return maxName;
// }