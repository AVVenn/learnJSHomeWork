// Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

// Для этого существуют два метода:

// setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
// setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

// __________________________________________________________________________________________________________________________________
// setTimeout
// let timerId = setTimeout(функция, задержка в милисекундах , аргумент, аргумент, ...)

// function sayHi(phrase, who) {
//     alert( phrase + ', ' + who );
// }
//   setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон

// __________________________________________________________________________________________________________________________________
// Передавайте функцию, но не запускайте её
// Начинающие разработчики иногда ошибаются, добавляя скобки () после функции:
// не правильно!
// setTimeout(sayHi(), 1000);

// __________________________________________________________________________________________________________________________________
// Отмена через clearTimeout
// Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.

// Синтаксис для отмены:
// let timerId = setTimeout(...);
// clearTimeout(timerId);


// В коде ниже планируем вызов функции и затем отменяем его (просто передумали). В результате ничего не происходит:
// let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
// alert(timerId); // идентификатор таймера
// clearTimeout(timerId);
// alert(timerId); // тот же идентификатор (не принимает значение null после отмены)


// __________________________________________________________________________________________________________________________________
// setInterval
// Метод setInterval имеет такой же синтаксис как setTimeout:

// let timerId = setInterval(функция, задержка в милисекундах , аргумент, аргумент, ...)

// Все аргументы имеют такое же значение. Но отличие этого метода от setTimeout в том, что функция запускается не один раз, а периодически через указанный интервал времени.
// Чтобы остановить дальнейшее выполнение функции, необходимо вызвать clearInterval(timerId).
// Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:

// повторить с интервалом 2 секунды
// let timerId = setInterval(() => alert('tick'), 2000);

// остановить вывод через 5 секунд
// setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);


// __________________________________________________________________________________________________________________________________
// Рекурсивный setTimeout

// Есть два способа запускать что-то регулярно.
// Один из них setInterval. Другим является рекурсивный setTimeout. Например:

/** вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/

// let timerId = setTimeout(function tick() {
//   alert('tick');
//   timerId = setTimeout(tick, 2000); // (*)
// }, 2000);

// Метод setTimeout выше планирует следующий вызов прямо после окончания текущего (*).

// Рекурсивный setTimeout – более гибкий метод, чем setInterval. С его помощью последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.
// Например, необходимо написать сервис, который отправляет запрос для получения данных на сервер каждые 5 секунд, но если сервер перегружен, то необходимо увеличить интервал запросов до 10, 20, 40 секунд… Вот псевдокод:

// let delay = 5000;
// let timerId = setTimeout(function request() {
//   ...отправить запрос...
//   if (ошибка запроса из-за перегрузки сервера) {
//     увеличить интервал для следующего запроса
//     delay *= 2;
//   }
//   timerId = setTimeout(request, delay);

// }, delay);


// __________________________________________________________________________________________________________________________________
// ПОТЕРЯ «this»

// Мы уже видели примеры потери this. Как только метод передаётся отдельно от объекта – this теряется.
// Вот как это может произойти в случае с setTimeout:

// let user = {
// firstName: "Вася",
// sayHi() {
//     alert(`Привет, ${this.firstName}!`);
// }
// };

// setTimeout(user.sayHi, 1000); // Привет, undefined!

// Это произошло потому, что setTimeout получил функцию sayHi отдельно от объекта user (именно здесь функция и потеряла контекст). То есть последняя строка может быть переписана как:
// let f = user.sayHi;
// setTimeout(f, 1000); // контекст user потеряли


// Метод setTimeout в браузере имеет особенность: он устанавливает this=window для вызова функции (в Node.js this становится объектом таймера, но здесь это не имеет значения). Таким образом, для this.firstName он пытается получить window.firstName, которого не существует. В других подобных случаях this обычно просто становится undefined.

// Задача довольно типичная – мы хотим передать метод объекта куда-то ещё (в этом конкретном случае – в планировщик), где он будет вызван. Как бы сделать так, чтобы он вызывался в правильном контексте?
// __________________________________________________________________________________________________________________________________
// Решение 1: сделать функцию-обёртку
// let user = {
//     firstName: "Вася",
//     sayHi() {
//       alert(`Привет, ${this.firstName}!`);
//     }
//   };

//   setTimeout(function() {
//     user.sayHi(); // Привет, Вася!
//   }, 1000);

// То же самое, только короче:
// setTimeout(() => user.sayHi(), 1000); // Привет, Вася!

// __________________________________________________________________________________________________________________________________
// Решение 2: привязать контекст с помощью bind

// Базовый синтаксис bind:
// let boundFunc = func.bind(context);  //устанавливается this=context.


// Другими словами, вызов boundFunc подобен вызову func с фиксированным this.
// Например, здесь funcUser передаёт вызов в func, фиксируя this=user:

// let user = {
//     firstName: "Вася"
// };

// function func() {
//     alert(this.firstName);
// }

// let funcUser = func.bind(user);
//   funcUser(); // Вася




// let user = {
//     firstName: "Вася",
//     sayHi() {
//       alert(`Привет, ${this.firstName}!`);
//     }
//   };

//   let sayHi = user.sayHi.bind(user); // мы берём метод user.sayHi и привязываем его к user. Теперь sayHi – это «связанная» функция, которая может быть вызвана отдельно или передана в setTimeout (контекст всегда будет правильным).

//   sayHi(); // Привет, Вася!

//   setTimeout(sayHi, 1000); // Привет, Вася!


// __________________________________________________________________________________________________________________________________
// Удобный метод: bindAll

// Если у объекта много методов и мы планируем их активно передавать, то можно привязать контекст для них всех в цикле:

// for (let key in user) {
//     if (typeof user[key] == 'function') {
//       user[key] = user[key].bind(user);
//     }
//   }

// __________________________________________________________________________________________________________________________________
// Частичное применение

// Мы можем привязать не только this, но и аргументы. Это делается редко, но иногда может быть полезно.

// Полный синтаксис bind:

// let bound = func.bind(context, [arg1], [arg2], ...);
// Это позволяет привязать контекст this и начальные аргументы функции.


// function mul(a, b) {
//     return a * b;
//   }
//   let double = mul.bind(null, 2);

//   alert( double(3) ); // = mul(2, 3) = 6
//   alert( double(4) ); // = mul(2, 4) = 8
//   alert( double(5) ); // = mul(2, 5) = 10
//   Вызов mul.bind(null, 2) создаёт новую функцию double, которая передаёт вызов mul, фиксируя null как контекст, и 2 – как первый аргумент. Следующие аргументы передаются как есть.
//   Это называется частичное применение – мы создаём новую функцию, фиксируя некоторые из существующих параметров.

// Обратите внимание, что в данном случае мы на самом деле не используем this. Но для bind это обязательный параметр, так что мы должны передать туда что-нибудь вроде null.


// В следующем коде функция triple умножает значение на три:

// function mul(a, b) {
//   return a * b;
// }

// let triple = mul.bind(null, 3);

// alert( triple(3) ); // = mul(3, 3) = 9
// alert( triple(4) ); // = mul(3, 4) = 12
// alert( triple(5) ); // = mul(3, 5) = 15

// __________________________________________________________________________________________________________________________________

// «Одалживание метода»

// При помощи call можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого.

// Используем эту технику для упрощения манипуляций с arguments.
// Как мы знаем, arguments не массив, а обычный объект, поэтому таких полезных методов как push, pop, join и других у него нет. Но иногда так хочется, чтобы были…

// Нет ничего проще! Давайте скопируем метод join из обычного массива:

// function printArgs() {
//   arguments.join = [].join; // одолжили метод (1)
//   var argStr = arguments.join(':'); // (2)
//   alert( argStr ); // сработает и выведет 1:2:3
// }
// printArgs(1, 2, 3)

// В строке (1) объявлен пустой массив [] и скопирован его метод [].join. Обратим внимание, мы не вызываем его, а просто копируем. Функция, в том числе встроенная – обычное значение, мы можем скопировать любое свойство любого объекта, и [].join здесь не исключение.
// В строке (2) запустили join в контексте arguments, как будто он всегда там был.
// Почему вызов сработает?
// Здесь метод join массива скопирован и вызван в контексте arguments. Не произойдёт ли что-то плохое от того, что arguments – не массив? Почему он, вообще, сработал?

// Ответ на эти вопросы простой. В соответствии со спецификацией, внутри join реализован примерно так:

// function join(separator) {
//   if (!this.length) return '';
//   var str = this[0];
//   for (var i = 1; i < this.length; i++) {
//     str += separator + this[i];
//   }
//   return str;
// }

// Как видно, используется this, числовые индексы и свойство length. Если эти свойства есть, то все в порядке. А больше ничего и не нужно.

// В качестве this подойдёт даже обычный объект:

// var obj = { // обычный объект с числовыми индексами и length
//   0: "А",
//   1: "Б",
//   2: "В",
//   length: 3
// };

// obj.join = [].join;
// alert( obj.join(';') ); // "A;Б;В"


// Представим на минуту, что вместо arguments у нас – произвольный объект. У него тоже есть числовые индексы, length и мы хотим вызвать в его контексте метод [].join. То есть, ситуация похожа на arguments, но (!) вполне возможно, что у объекта есть свой метод join.

// Поэтому копировать [].join, как сделано выше, нельзя: если он перезапишет собственный join объекта, то будет страшный бардак и путаница.

// Безопасно вызвать метод нам поможет call:

// function printArgs() {
//   var join = [].join; // скопируем ссылку на функцию в переменную
//   вызовем join с this=arguments,
//    этот вызов эквивалентен arguments.join(':') из примера выше
//   var argStr = join.call(arguments, ':');
//   alert( argStr ); // сработает и выведет 1:2:3
// }
// printArgs(1, 2, 3);

// Мы вызвали метод без копирования. Чисто, безопасно.
// __________________________________________________________________________________________________________________________________
// Ещё пример: [].slice.call(arguments)

// В JavaScript есть очень простой способ сделать из arguments настоящий массив. Для этого возьмём метод массива: slice.
// По стандарту вызов arr.slice(start, end) создаёт новый массив и копирует в него элементы массива arr от start до end. А если start и end не указаны, то копирует весь массив.

// Вызовем его в контексте arguments:

// function printArgs() {
//   вызов arr.slice() скопирует все элементы из this в новый массив
//   var args = [].slice.call(arguments);
//   alert( args.join(', ') ); // args - полноценный массив из аргументов
// }

// printArgs('Привет', 'мой', 'мир'); // Привет, мой, мир
// Как и в случае с join, такой вызов технически возможен потому, что slice для работы требует только нумерованные свойства и length. Всё это в arguments есть.