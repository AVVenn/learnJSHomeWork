// Пустой объект («пустой ящик») можно создать, используя один из двух вариантов синтаксиса:
// let user = new Object(); // синтаксис "конструктор объекта"
// let user = {};  // синтаксис "литерал объекта"
// __________________________________________________________________________________________________________________________________
// let user = {     // объект
//     name: "John",  // под ключом "name" хранится значение "John"
//     age: 30        // под ключом "age" хранится значение 30
//   };
// __________________________________________________________________________________________________________________________________
// ОБРАЩЕНИЕ
// Для обращения к свойствам используется запись «через точку»:
// получаем свойства объекта:
// alert( user.name ); // John
// alert( user.age ); // 30
// __________________________________________________________________________________________________________________________________
// УДАЛЕНИЕ
// Для удаления свойства мы можем использовать оператор delete:
// delete user.age;
// __________________________________________________________________________________________________________________________________
// ИМЯ СВОЙСТВА ИЗ НЕСКОЛЬКИХ СЛОВ
// let user = {
//     name: "John",
//     age: 30,
//     "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
//   };
// __________________________________________________________________________________________________________________________________
// ИЗМЕНЕНИЕ ЗНАЧЕНИЯ СВОЙСТВА
// const user = {
//     name: "John"
//   };
//   user.name = "Pete";
//   alert(user.name); // Pete
// __________________________________________________________________________________________________________________________________
// КВАДРАТНЫЕ СКОБКИ
// let user = {};
//  присваивание значения свойству
// user["likes birds"] = true;
// получение значения свойства
// alert(user["likes birds"]); // true
// удаление свойства
// delete user["likes birds"];


// Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:

// let key = "likes birds";
//  то же самое, что и user["likes birds"] = true;
// user[key] = true;


// let user = {
//     name: "John",
//     age: 30
//   };
//   let key = prompt("Что вы хотите узнать о пользователе?", "name");
//   /доступ к свойству через переменную
//   alert( user[key] ); // John (если ввели "name")

// -------------------------------------------------------------------------------
// Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.

// let fruit = prompt("Какой фрукт купить?", "apple");
// let bag = {
//   [fruit]: 5, // имя свойства будет взято из переменной fruit
// };
// alert( bag.apple ); // 5, если fruit="apple"

// Смысл вычисляемого свойства прост: запись [fruit] означает, что имя свойства необходимо взять из переменной fruit.
// И если посетитель введёт слово "apple", то в объекте bag теперь будет лежать свойство {apple: 5}.

// -------------------------------------------------------------------------------
// более сложные выражения
// let fruit = 'apple';
// let bag = {
//   [fruit + 'Computers']: 5 // bag.appleComputers = 5
// };

// __________________________________________________________________________________________________________________________________
// СОКРАЩЕНИЯ

// function makeUser(name, age) {
//     return {
//       name: name,
//       age: age
//       ...другие свойства
//     };
//   }
//   let user = makeUser("John", 30);
//   alert(user.name); // John


// ЗАМЕНИТЬ НА 

// function makeUser(name, age) {
//     return {
//       name, // то же самое, что и name: name
//       age   // то же самое, что и age: age
//        ...
//     };
//   }

// __________________________________________________________________________________________________________________________________
// нет никаких ограничений к именам свойств. Они могут быть в виде строк или символов (специальный тип для идентификаторов, который будет рассмотрен позже).
// Все другие типы данных будут автоматически преобразованы к строке.
// Например, если использовать число 0 в качестве ключа, то оно превратится в строку "0":

// let obj = {
//     0: "Тест" // то же самое что и "0": "Тест"
//   };

//   обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
//   alert( obj["0"] ); // Тест
//   alert( obj[0] ); // Тест (то же свойство)


// __________________________________________________________________________________________________________________________________
// ПРОВЕРКА НА СУЩЕСТВОВАНИЕ. ОПЕРАТОР IN

// В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!

// "key" in object - key - это  свойство

// let user = { name: "John", age: 30 };
// alert( "age" in user ); // true, user.age существует
// alert( "blabla" in user ); // false, user.blabla не существует

// __________________________________________________________________________________________________________________________________
// ЦИКЛ «for…in»

// for (key in object) {
    // тело цикла выполняется для каждого свойства объекта
//   }

// let user = {
//     name: "John",
//     age: 30,
//     isAdmin: true
//   };

//   for (let key in user) {
//      ключи
//     alert( key );  // name, age, isAdmin
//      значения ключей
//     alert( user[key] ); // John, 30, true
//   }

// Кроме того, мы могли бы использовать другое имя переменной. Например, часто используется вариант "for (let prop in obj)".

// __________________________________________________________________________________________________________________________________
// УПОРЯДОЧЕНИЕ СВОЙСТВ ОБЪЕКТА

// свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания. Разберёмся подробнее.

// __________________________________________________________________________________________________________________________________
// ...................................КОПИРОВАНИЕ ОБЪЕКТОВ И ССЫЛКИ!..................................................................


// Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».
// Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».
// Например:
// let message = "Привет!";
// let phrase = message;
// В результате мы имеем две независимые переменные, каждая из которых хранит строку "Привет!".


// У ОБЪЕКТОВ ИНАЧЕ:
// Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.
// Проиллюстрируем это:
// let user = {
//   name: "Иван"
// };

// Сам объект хранится где-то в памяти. А в переменной user лежит «ссылка» на эту область памяти.
// Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.
// Если мы представляем объект как ящик, то переменная – это ключ к нему. Копирование переменной дублирует ключ, но не сам ящик.
// Например:

// let user = { name: "Иван" };
// let admin = user; // копируется ссылка

// Теперь у нас есть две переменные, каждая из которых содержит ссылку на один и тот же объект:

// Мы можем использовать любую из переменных для доступа к ящику и изменения его содержимого:
// let user = { name: 'Иван' };
// let admin = user;
// admin.name = 'Петя'; // изменено по ссылке из переменной "admin"
// alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"

// Два объекта равны только в том случае, если это один и тот же объект:
// let a = {};
// let b = a; // копирование по ссылке
// alert( a == b ); // true, т.к. обе переменные ссылаются на один и тот же объект
// alert( a === b ); // true


// В другом примере два разных объекта не равны, хотя оба пусты:
// let a = {};
// let b = {}; // два независимых объекта
// alert( a == b ); // false

// __________________________________________________________________________________________________________________________________
//КЛОНИРОВАНИЕ И ОБЪЕДМНЕНИЕ ОБЪЕКТОВ - !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// let user = {
//     name: "Иван",
//     age: 30
// };
//   let clone = {}; // новый пустой объект
//   скопируем все свойства user в него
// for (let key in user) {
// clone[key] = user[key];
// }
//   теперь в переменной clone находится абсолютно независимый клон объекта
//   clone.name = "Пётр"; // изменим в нём данные
//   alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Иван.

// __________________________________________________________________________________________________________________________________
// Object.assign - !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// Кроме того, для этих целей мы можем использовать метод Object.assign.

// Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
// Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно) являются исходными объектами
// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть, свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
// Возвращает объект dest

// Например, объединим несколько объектов в один:
// let user = { name: "Иван" };
// let permissions1 = { canView: true };
// let permissions2 = { canEdit: true };
// копируем все свойства из permissions1 и permissions2 в user
// Object.assign(user, permissions1, permissions2);
// теперь user = { name: "Иван", canView: true, canEdit: true }

// Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано

// __________________________________________________________________________________________________________________________________

// Мы также можем использовать Object.assign для замены for..in на простое клонирование:
// let user = {
//   name: "Иван",
//   age: 30
// };
// let clone = Object.assign({}, user);
// Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.

// __________________________________________________________________________________________________________________________________
// Object.keys(obj) – возвращает массив ключей.
// Object.values(obj) – возвращает массив значений.
// Object.entries(obj) – возвращает массив пар [ключ, значение].


// let user = {
//     name: "Иван",
//     age: 30
//   };
//   let clone = {}; // новый пустой объект
// // скопируем все свойства user в него
// for (let key in user) {
//   clone[key] = user[key];
// }
// clone.name = "Пётр"; // изменим в нём данные
// console.log (user); 
// console.log (clone);


// let user = {
//     name: "Джон",
//     age: 30,
//     sayHi() {
//       // this - это "текущий объект"
//       alert(this.name);
//     }
// };
// user.sayHi(); 

// const calculator = {
//     read: function () {
//         this.a = +prompt('a?', 0);
//         this.b = +prompt('b?', 0);
//     },
//     sum: function () {
//         return this.a+this.b;
//     },
//     mul: function() {
//         return = this.a*this.b;
//     }
// }

// calculator.read();
// alert( calculator.sum() );
// alert( calculator.mul() );

// let ladder = {
//     step: 0,
//     up() {
//         this.step++;
//         return this;
//     },
//     down() {
//         this.step--;
//         return this;
//     },
//     showStep: function() { // показывает текущую ступеньку
//         alert( this.step );
//     }
// };


// // Измените код методов up, down и showStep таким образом, чтобы их вызов можно было сделать по цепочке, например так:
// ladder.up().up().down().showStep(); // 1