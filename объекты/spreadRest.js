// Spread/Rest    Остаточные параметры и оператор расширения 

// Остаточные параметры (...) REST

// Вызывать функцию можно с любым количеством аргументов независимо от того, как она была определена.
// Например:

// function sum(a, b) {
//   return a + b;
// }
// alert( sum(1, 2, 3, 4, 5) );

// Лишние аргументы не вызовут ошибку. Но, конечно, посчитаются только первые два.
// Остаточные параметры могут быть обозначены через три точки ... Буквально это значит: «собери оставшиеся параметры и положи их в массив».
// Например, соберём все аргументы в массив args:

// function sumAll(...args) { // args — имя массива
//   let sum = 0;
//   for (let arg of args) sum += arg;
//   return sum;
// }

// alert( sumAll(1) ); // 1
// alert( sumAll(1, 2) ); // 3
// alert( sumAll(1, 2, 3) ); // 6
// Мы можем положить первые несколько параметров в переменные, а остальные – собрать в массив.


// В примере ниже первые два аргумента функции станут именем и фамилией, а третий и последующие превратятся в массив titles:

// function showName(firstName, lastName, ...titles) {
//   alert( firstName + ' ' + lastName ); // Юлий Цезарь
//   Оставшиеся параметры пойдут в массив
//   titles = ["Консул", "Император"]
//   alert( titles[0] ); // Консул
//   alert( titles[1] ); // Император
//   alert( titles.length ); // 2
// }

// showName("Юлий", "Цезарь", "Консул", "Император");

// function rest (...arr){
//     console.log(typeof arr);
//     return console.log(arr);
// }
// rest (1,2,3,4,5,6);
// .................................................Остаточные параметры должны располагаться в конце........................

// __________________________________________________________________________________________________________________________________
// Переменная "arguments" ....................НО ЛУЧШЕ ИСПОЛЬЗОВАТЬ REST (...)
// Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами.
// Объект arguments можно перебирать циклом ( как и массив)  
// Стрелочные функции не имеют "arguments"

// __________________________________________________________________________________________________________________________________
// ....................................Оператор расширения SPREAD

// Мы узнали, как получить массив из списка параметров.
// Но иногда нужно сделать в точности противоположное.

// Например, есть встроенная функция Math.max. Она возвращает наибольшее число из списка:

// alert( Math.max(3, 5, 1) ); // 5
// Допустим, у нас есть массив чисел [3, 5, 1]. Как вызвать для него Math.max?

// Просто так их не вставишь — Math.max ожидает получить список чисел, а не один массив.

// let arr = [3, 5, 1];
// alert( Math.max(arr) ); // NaN

// Конечно, мы можем вводить числа вручную : Math.max(arr[0], arr[1], arr[2]). Но, во-первых, это плохо выглядит, а, во-вторых, мы не всегда знаем, сколько будет аргументов. Их может быть как очень много, так и не быть совсем.

// И тут нам поможет оператор расширения. Он похож на остаточные параметры – тоже использует ..., но делает совершенно противоположное.
// Когда ...arr используется при вызове функции, он «расширяет» перебираемый объект arr в список аргументов.

// Для Math.max:
// let arr = [3, 5, 1];
// alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)

// Этим же способом мы можем передать несколько итерируемых объектов:

// let arr1 = [1, -2, 3, 4];
// let arr2 = [8, 3, -8, 1];

// alert( Math.max(...arr1, ...arr2) ); // 8
// Мы даже можем комбинировать оператор расширения с обычными значениями:

// let arr1 = [1, -2, 3, 4];
// let arr2 = [8, 3, -8, 1];

// alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
// Оператор расширения можно использовать и для слияния массивов:

// let arr = [3, 5, 1];
// let arr2 = [8, 9, 15];

// let merged = [0, ...arr, 2, ...arr2];
// alert(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)

// В примерах выше мы использовали массив, чтобы продемонстрировать свойства оператора расширения, но он работает с любым перебираемым объектом.
// Например, оператор расширения подойдёт для того, чтобы превратить строку в массив символов:

// let str = "Привет";
// alert( [...str] ); // П,р,и,в,е,т

// __________________________________________________________________________________________________________________________________
//   Так же для этой задачи мы можем использовать и Array.from. Он тоже преобразует перебираемый объект (такой как строка) в массив:
// let str = "Привет";

// Array.from преобразует перебираемый объект в массив
// alert( Array.from(str) ); // П,р,и,в,е,т
// Результат аналогичен [...str].

// Но между Array.from(obj) и [...obj] есть разница:

// Array.from работает как с псевдомассивами, так и с итерируемыми объектами
// Оператор расширения работает только с итерируемыми объектами
// Выходит, что если нужно сделать из чего угодно массив, то Array.from — более универсальный метод.
// __________________________________________________________________________________________________________________________________
// ...................................Как отличить их друг от друга:

// Если ... располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает остальные неуказанные аргументы и делает из них массив.
// Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
// Полезно запомнить:

// Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
// С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с обычным списком аргументов.
// __________________________________________________________________________________________________________________________________
// примеры
// let arr = [1,2,3,4,5,6,7,8,9];
// const arr2 = [10,12,13,14,15,16,17,18,19];
// alert (Math.max(1 , ...arr, ...arr2)); // 19        Раскрыли 2 массива и нашли максимальное число

// let arr = [1,2,3,4,5,6,7,8,9];
// const arr2 = [10,12,13,14,15,16,17,18,19];
// let accum = [...arr, ...arr2, 27];
// alert (accum);  // два массива объединеные  и 27


// const person = {
//     age: 23,
//     name: 'John',
//     stack: ['HTML', 'CSS', 'JS'],
//     city: 'Gomel',
// };
// const person2 = {
//     ...person,
//     city: 'Homel',
// } 
// console.log (person2);   в объект person2 cкопировали поля объекта person и перезаписали city

// const person = {
//     name: 'John',
//     age: 23,
//     stack: ['HTML', 'CSS', 'JS']
// };
// const programmer = {
//     ...person,     //   в объект person2 cкопировали поля объекта person и перезаписали city
//     isProgrammer: true,
//     stack: [...person.stack, `JS`]     // в путой массив хзасунули значения  массива stack из person и убедились , что это отдельный масив , а не ссылка
// };
// console.log (programmer);
// console.log (person);
