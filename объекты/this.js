// ФУНКЦИЮ, которая является СВОЙСТВО ОБЪЕКТА, называют МЕТОД ЭТОГО ОБЪЕКТА.

// Пример метода

// let user = {
//     name: "Джон",
//     age: 30
//   };
//   user.sayHi = function() {
//     alert("Привет!");
//   };
//   user.sayHi(); // Привет!
// __________________________________________________________________________________________________________________________________

// СОКРАЩЕННАЯ ЗАПИСЬ МЕТОДА

// эти объекты делают одно и то же (одинаковые методы)

// user = {
//     sayHi: function() {
//       alert("Привет");
//     }
// };
//    сокращённая запись выглядит лучше, не так ли?
// user = {
//     sayHi() { // то же самое, что и "sayHi: function()"
//       alert("Привет");
//     }
// };

// Как было показано, мы можем пропустить ключевое слово "function" и просто написать sayHi().
// __________________________________________________________________________________________________________________________________
// КЛЮЧЕВОЕ СЛОВО this в методах

// Как правило, методу объекта необходим доступ к информации, которая хранится в объекте, чтобы выполнить с ней какие-либо действия (в соответствии с назначением метода).
// Например, коду внутри user.sayHi() может понадобиться имя пользователя, которое хранится в объекте user.

// Для доступа к информации внутри объекта метод может использовать ключевое слово this.
// Значение this – это объект «перед точкой», который использовался для вызова метода.

// let user = {
//     name: "Джон",
//     age: 30,
//     sayHi() {
//       alert(this.name);    // this - это "текущий объект"
//     }
//   };
//   user.sayHi(); // Джон

// Здесь во время выполнения кода user.sayHi() значением this будет являться user (ссылка на объект user).

// __________________________________________________________________________________________________________________________________
// «this» НЕ ЯВЛЯЕТСЯ ФИКСИРОВАННЫМ

// Значение this вычисляется во время выполнения кода и зависит от контекста.
// Например, здесь одна и та же функция назначена двум разным объектам и имеет различное значение «this» при вызовах:


// let user = { name: "Джон" };
// let admin = { name: "Админ" };

// function sayHi() {
//   alert( this.name );
// }

// ............используем одну и ту же функцию в двух объектах
// user.f = sayHi;
// admin.f = sayHi;

// .............вызовы функции, приведённые ниже, имеют разное значение this
//  "this" внутри функции является ссылкой на объект, который указан "перед точкой"

// user.f(); // Джон  (this == user)
// admin.f(); // Админ  (this == admin)
// admin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)

// Правило простое: при вызове obj.f() значение this внутри f равно obj. Так что, в приведённом примере это user или admin.

// __________________________________________________________________________________________________________________________________
// ВЫЗОВ БЕЗ ОБЪЕКТА: this == undefined

// Мы даже можем вызвать функцию вовсе без использования объекта:

// function sayHi() {
//   alert(this);
// }
// sayHi(); // undefined

// __________________________________________________________________________________________________________________________________
// Внутренняя реализация: Ссылочный тип


// Некоторые хитрые способы вызова метода приводят к потере значения this, например:

// let user = {
//     name: "Джон",
//     hi() { alert(this.name); },
//     bye() { alert("Пока"); }
//   };

//   user.hi(); // Джон (простой вызов метода работает хорошо)

//   теперь давайте попробуем вызывать user.hi или user.bye
//   в зависимости от имени пользователя user.name
//   (user.name == "Джон" ? user.hi : user.bye)(); // Ошибка!

// Почему? Если мы хотим понять, почему так происходит, давайте разберёмся (заглянем под капот), как работает вызов методов (obj.method()).

// Присмотревшись поближе, в выражении obj.method() можно заметить две операции:

// Сначала оператор точка '.' возвращает свойство объекта – его метод (obj.method).
// Затем скобки () вызывают этот метод (исполняется код метода).
// Итак, каким же образом информация о this передаётся из первой части во вторую?

// Если мы поместим эти операции в отдельные строки, то значение this, естественно, будет потеряно:
// let user = {
//   name: "Джон",
//   hi() { alert(this.name); }
// };
// разделим получение метода объекта и его вызов в разных строках
// let hi = user.hi;
// hi(); // Ошибка, потому что значением this является undefined
// Здесь hi = user.hi сохраняет функцию в переменной, и далее в последней строке она вызывается полностью сама по себе, без объекта, так что нет this.

// Для работы вызовов типа user.hi(), JavaScript использует трюк – точка '.' возвращает не саму функцию, а специальное значение «ссылочного типа», называемого Reference Type.

// Этот ссылочный тип (Reference Type) является внутренним типом. Мы не можем явно использовать его, но он используется внутри языка.
// Значение ссылочного типа – это «триплет»: комбинация из трёх значений (base, name, strict), где:

// base – это объект.
// name – это имя свойства объекта.
// strict – это режим исполнения. Является true, если действует строгий режим (use strict).
// Результатом доступа к свойству user.hi является не функция, а значение ссылочного типа. Для user.hi в строгом режиме оно будет таким:

// (user, "hi", true)
// Когда скобки () применяются к значению ссылочного типа (происходит вызов), то они получают полную информацию об объекте и его методе, и могут поставить правильный this (=user в данном случае, по base).


// Ссылочный тип – исключительно внутренний, промежуточный, используемый, чтобы передать информацию от точки . до вызывающих скобок ().

// При любой другой операции, например, присваивании hi = user.hi, ссылочный тип заменяется на собственно значение user.hi (функцию), и дальше работа уже идёт только с ней. Поэтому дальнейший вызов происходит уже без this.

// Таким образом, значение this передаётся правильно, только если функция вызывается напрямую с использованием синтаксиса точки obj.method() или квадратных скобок obj['method']() (они делают то же самое). Позднее в этом учебнике мы изучим различные варианты решения проблемы потери значения this. Например, такие как func.bind().

// __________________________________________________________________________________________________________________________________
//У СТРЕЛОЧНЫХ ФУНКЦИЙ НЕТ «this»

// Стрелочные функции особенные: у них нет своего «собственного» this. Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.
// Например, здесь arrow() использует значение this из внешнего метода user.sayHi():
// let user = {
//     firstName: "Илья",
//     sayHi() {
//       let arrow = () => alert(this.firstName);
//       arrow();
//     }
//   };
//   user.sayHi(); // Илья

// Это является особенностью стрелочных функций. Они полезны, когда мы на самом деле не хотим иметь отдельное значение this, а хотим брать его из внешнего контекста. Позднее в главе Повторяем стрелочные функции мы увидим больше примеров на эту тему.